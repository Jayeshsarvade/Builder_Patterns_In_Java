
1. Definition of Abstract Factory Pattern
    Abstract Factory Pattern is a Creational Design Pattern that lets you create families of related objects without specifying their exact classes.
    Instead of having a single factory method, we now have a factory of factories — meaning you can create a factory object that creates objects of a particular family or category.

In your code:
    We have different factories (AndroidDevFactory, WebDevFactory) that each create their own employee.
    The client doesn’t know the concrete class; it only talks to the abstract EmployeeAbstractFactory.

2. How Your Code Fits This Pattern
    Let’s map your classes to Abstract Factory concepts:
    | **Component**          | **Your Code**                              | **Purpose**                                                  |
    | ---------------------- | ------------------------------------------ | ------------------------------------------------------------ |
    | **Abstract Product**   | `Employee` interface                       | Common interface for all products.                           |
    | **Concrete Products**  | `AndroidDeveloper`, `WebDeveloper`         | Actual objects created.                                      |
    | **Abstract Factory**   | `EmployeeAbstractFactory` (abstract class) | Declares `createEmployee()` method.                          |
    | **Concrete Factories** | `AndroidDevFactory`, `WebDevFactory`       | Implement `createEmployee()` to return respective employees. |
    | **Client**             | `ClientMain`                               | Requests employees **via factory**, not `new`.               |

So now instead of a single static factory method, we have multiple factory classes, making it more scalable and organized.

3. Why Use Abstract Factory Pattern?

Use it when:
    You have families of related products (like Employee types).
    You want to encapsulate object creation in multiple factories (each family gets its own factory).
    You want loose coupling: The client never uses new and doesn’t know exact classes.
    You want your system to be easily extendable by adding new products and factories.

4. Code Flow (Example):
    ClientMain → chooses a factory (AndroidDevFactory) → calls createEmployee()
        → gets AndroidDeveloper object via interface → calls methods

Key Benefit:
    Adding a new developer type (say iOSDeveloper):
        Create iOSDeveloper class.
        Create iOSDevFactory class.
        Client can use it without changing any other code.

5. Interview-Ready Answer
    “The Abstract Factory Pattern is a creational design pattern that provides an interface to create families of related objects without specifying their concrete classes.
    In my example, I created an Employee interface (product) and two concrete classes (AndroidDeveloper, WebDeveloper). I also created an abstract factory EmployeeAbstractFactory, which is extended by AndroidDevFactory and WebDevFactory.
    The client simply chooses which factory to use and calls createEmployee(), so it never needs to know the concrete class or call new.
    This pattern is used when we have multiple families of objects and want to keep object creation centralized and decoupled. It makes the code flexible and scalable.”

Pros and Cons:
    | Pros                                          | Cons                             |
    | --------------------------------------------- | -------------------------------- |
    | Loose coupling between client and product     | More classes and complexity      |
    | Easy to add new product families              | Might be overkill for small apps |
    | Centralized object creation                   |                                  |
    | Works well with dependency injection & Spring |                                  |

Real-World Examples
    Spring Framework: ApplicationContext is an abstract factory that gives beans without knowing concrete classes.
    JDBC: DriverManager chooses the right driver factory.
    GUI Toolkits: Different look-and-feel factories (WindowsFactory, MacFactory) create UI components.

Simple UML Diagram (Example):
                +----------------------+
                |  Employee (interface)|
                +----------------------+
                  ^                 ^
                  |                 |
     +----------------------+ +---------------------+
     | AndroidDeveloper     | | WebDeveloper       |
     +----------------------+ +---------------------+

                +------------------------------+
                | EmployeeAbstractFactory      |
                | + createEmployee() :Employee|
                +------------------------------+
                   ^                      ^
                   |                      |
    +------------------------+  +----------------------+
    | AndroidDevFactory      |  | WebDevFactory       |
    | + createEmployee()     |  | + createEmployee()  |
    +------------------------+  +----------------------+

               +-------------------+
               |    ClientMain     |
               +-------------------+
