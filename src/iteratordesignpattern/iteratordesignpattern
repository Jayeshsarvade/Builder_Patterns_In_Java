
1. Definition of Iterator Design Pattern
    The Iterator Design Pattern is a Behavioral Design Pattern that provides a way to access elements of a collection (like ArrayList, List, etc.) sequentially without exposing the underlying implementation.
    It lets you traverse a collection without needing to know how the collection is stored internally.

2. Why We Use It
    To separate traversal logic from the collection’s internal structure.
    Makes your code cleaner and more maintainable because clients only deal with an iterator, not the internal details of your collection.
    You can easily change how you iterate (forward, backward, filtering, etc.) without changing client code.
    Standard Java Iterator interface is a real-world implementation of this pattern.

3. How Your Code Fits This Pattern
    | **Pattern Element**        | **Your Code**          | **Purpose**                                    |
    | -------------------------- | ---------------------- | ---------------------------------------------- |
    | **Aggregate / Collection** | `UserManagement` class | Stores a collection of `User` objects.         |
    | **Iterator Interface**     | `MyIterator` interface | Declares `hasNext()` and `next()`.             |
    | **Concrete Iterator**      | `MyIteratorImpl`       | Implements `hasNext()` and `next()`.           |
    | **Client Code**            | `IteratorMain` class   | Uses `MyIterator` to loop through `User` list. |

4. Code Flow
    UserManagement holds a list of User objects.
    When getIterator() is called, it returns a MyIteratorImpl object.
    MyIteratorImpl knows how to traverse the list (using position index).
    The client (IteratorMain) simply calls:
    while(iterator.hasNext()) {
        User user = (User) iterator.next();
    }
Without knowing the underlying ArrayList details.

5. Interview-Ready Explanation
    “The Iterator Design Pattern is a behavioral design pattern that allows sequential access to elements of a collection without exposing the internal structure.
    In my example, UserManagement holds a list of User objects. I created a MyIterator interface with hasNext() and next() methods, and MyIteratorImpl implements the actual traversal.
    The client code doesn’t know that UserManagement uses an ArrayList internally — it only uses the iterator. This pattern improves encapsulation and makes traversal logic reusable and easy to modify.
    Java’s built-in Iterator and ListIterator classes are real-world examples of this pattern.”

6. Benefits of Iterator Pattern
    | Benefit                    | Explanation                                                   |
    | -------------------------- | ------------------------------------------------------------- |
    | **Encapsulation**          | Internal structure of collection is hidden from client.       |
    | **Separation of Concerns** | Traversal logic is separated from collection logic.           |
    | **Flexibility**            | Easy to change how you traverse (reverse, filter, etc.).      |
    | **Consistency**            | Same interface for traversing different types of collections. |

7. Drawbacks:
    | Drawback                                        |
    | ----------------------------------------------- |
    | Adds extra classes (Iterator Interface & Impl). |
    | Might be overkill for very small collections.   |

Real-World Examples
    Java Collections API: Iterator interface (hasNext(), next(), remove()).
    ResultSet in JDBC: Iterating through database query results.
    Spring Framework: Iterating through beans or configurations.
    For-Each loop in Java: Uses Iterable internally, which is based on Iterator pattern.

UML Diagram (Example)
              +-------------------+
              |     MyIterator    |
              |-------------------|
              | + hasNext():bool  |
              | + next():Object   |
              +-------------------+
                        ^
                        |
              +-------------------+
              |  MyIteratorImpl   |
              |-------------------|
              | - list: List<User>|
              | - length: int     |
              | - position: int   |
              +-------------------+
              | + hasNext()       |
              | + next()          |
              +-------------------+

              +-------------------+
              |   UserManagement  |
              |-------------------|
              | - users:ArrayList |
              +-------------------+
              | + addUser()       |
              | + getIterator()   |
              +-------------------+

              +--------+
              |  User   |
              +--------+

    Client (IteratorMain) → uses MyIterator to traverse UserManagement

Key Difference Between Iterator and a Normal For-Loop
    | **Iterator**                         | **For Loop**                         |
    | ------------------------------------ | ------------------------------------ |
    | Works with different collections     | Requires knowing the collection type |
    | Encapsulates internal structure      | Exposes or assumes collection logic  |
    | Extensible (filtering, custom logic) | Harder to extend                     |
